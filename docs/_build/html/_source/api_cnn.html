
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cnn - A Python module for common-nearest-neighbour (CNN) clustering &#8212; cnnclustering  documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="cmsm - A Python module for coreset Markov-state model estimation" href="api_cmsm.html" />
    <link rel="prev" title="API Reference" href="api_reference.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <span class="target" id="module-cnnclustering.cnn"><span id="sec-api-cnn"></span></span><div class="section" id="cnn-a-python-module-for-common-nearest-neighbour-cnn-clustering">
<h1>cnn - A Python module for common-nearest-neighbour (CNN) clustering<a class="headerlink" href="#cnn-a-python-module-for-common-nearest-neighbour-cnn-clustering" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt id="cnnclustering.cnn.CNN">
<em class="property">class </em><code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">CNN</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Any<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">distances</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Any<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">neighbourhoods</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Any<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">graph</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Any<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">labels</span><span class="p">:</span> <span class="n">Collection<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">alias</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'root'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.CNN" title="Permalink to this definition">¶</a></dt>
<dd><p>CNN cluster object</p>
<p>A cluster object connects input data (points, distances, neighbours,
or density graphs) to cluster results (labels) and clustering
methodologies (fits).
It also interfaces several convenience functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> – Argument passed on to <a class="reference internal" href="#cnnclustering.cnn.Data" title="cnnclustering.cnn.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></a> to construct
attribute <cite>data</cite>.</p></li>
<li><p><strong>distances</strong> – Argument passed on to <a class="reference internal" href="#cnnclustering.cnn.Data" title="cnnclustering.cnn.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></a> to construct
attribute <cite>data</cite>.</p></li>
<li><p><strong>neighbourhoods</strong> – Argument passed on to <a class="reference internal" href="#cnnclustering.cnn.Data" title="cnnclustering.cnn.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></a> to construct
attribute <cite>data</cite>.</p></li>
<li><p><strong>graph</strong> – Argument passed on to <a class="reference internal" href="#cnnclustering.cnn.Data" title="cnnclustering.cnn.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></a> to construct attribute
<a class="reference internal" href="#cnnclustering.cnn.CNN.data" title="cnnclustering.cnn.CNN.data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code></a>.</p></li>
<li><p><strong>labels</strong> – Argument passed on to <a class="reference internal" href="#cnnclustering.cnn.Labels" title="cnnclustering.cnn.Labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Labels</span></code></a> to construct
attribute <a class="reference internal" href="#cnnclustering.cnn.CNN.labels" title="cnnclustering.cnn.CNN.labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">labels</span></code></a>.</p></li>
<li><p><strong>alias</strong> – Descriptive object identifier.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="cnnclustering.cnn.CNN.data">
<code class="sig-name descname">data</code><a class="headerlink" href="#cnnclustering.cnn.CNN.data" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of <a class="reference internal" href="#cnnclustering.cnn.Data" title="cnnclustering.cnn.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.CNN.labels">
<code class="sig-name descname">labels</code><a class="headerlink" href="#cnnclustering.cnn.CNN.labels" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of <a class="reference internal" href="#cnnclustering.cnn.Labels" title="cnnclustering.cnn.Labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Labels</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.CNN.alias">
<code class="sig-name descname">alias</code><a class="headerlink" href="#cnnclustering.cnn.CNN.alias" title="Permalink to this definition">¶</a></dt>
<dd><p>Descriptive object identifier.</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.CNN.hierarchy_level">
<code class="sig-name descname">hierarchy_level</code><a class="headerlink" href="#cnnclustering.cnn.CNN.hierarchy_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Level in the cluster hierarchy of the cluster
object.</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.CNN.summary">
<code class="sig-name descname">summary</code><a class="headerlink" href="#cnnclustering.cnn.CNN.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of <a class="reference internal" href="#cnnclustering.cnn.Summary" title="cnnclustering.cnn.Summary"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Summary</span></code></a> collecting recorded
cluster results.</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.CNN.status">
<code class="sig-name descname">status</code><a class="headerlink" href="#cnnclustering.cnn.CNN.status" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary summarising the current state of the cluster
object.</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.CNN.children">
<code class="sig-name descname">children</code><a class="headerlink" href="#cnnclustering.cnn.CNN.children" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary of child cluster objects
(of type <a class="reference internal" href="#cnnclustering.cnn.CNNChild" title="cnnclustering.cnn.CNNChild"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CNNChild</span></code></a>).  Created from cluster label
assignments by <a class="reference internal" href="#cnnclustering.cnn.CNN.isolate" title="cnnclustering.cnn.CNN.isolate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isolate()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.CNN.calc_dist">
<code class="sig-name descname">calc_dist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Type<span class="p">[</span>CNN<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">v</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">method</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'cdist'</span></em>, <em class="sig-param"><span class="n">mmap</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">mmap_file</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Union<span class="p">[</span>pathlib.Path<span class="p">, </span>str<span class="p">, </span>IO<span class="p">[</span>bytes<span class="p">]</span><span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">chunksize</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">10000</span></em>, <em class="sig-param"><span class="n">progress</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.CNN.calc_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a distance matrix</p>
<p>Requires <a class="reference internal" href="#cnnclustering.cnn.Data.points" title="cnnclustering.cnn.Data.points"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Data.points</span></code></a>, computes distances and
sets <a class="reference internal" href="#cnnclustering.cnn.Data.distances" title="cnnclustering.cnn.Data.distances"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Data.distances</span></code></a>.</p>
<dl class="simple">
<dt>Note: Currently only working for point objects of</dt><dd><p>type <a class="reference internal" href="#cnnclustering.cnn.Points" title="cnnclustering.cnn.Points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Points</span></code></a> and distances of type <a class="reference internal" href="#cnnclustering.cnn.Distances" title="cnnclustering.cnn.Distances"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distances</span></code></a>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> – If not <cite>None</cite>, a second <a class="reference internal" href="#cnnclustering.cnn.CNN" title="cnnclustering.cnn.CNN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CNN</span></code></a> cluster object.
Distances are calculated between <em>n</em> points in <cite>self</cite>
and <em>m</em> points in <cite>other</cite>.  If <cite>None</cite>, distances are
calculated within <cite>self</cite>.</p></li>
<li><p><strong>v</strong> – Be chatty.</p></li>
<li><p><strong>method</strong> – <p>Method to compute distances
with:</p>
<blockquote>
<div><ul>
<li><p>cdist: <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cdist.html">scipy.spatial.distance.cdist</a>.</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>mmap</strong> – Wether to memory map the calculated distances on disk
with NumPy.</p></li>
<li><p><strong>mmap_file</strong> – If <cite>mmap</cite> is set to <cite>True</cite>, where to store the
file.  If <cite>None</cite>, uses a temporary file.</p></li>
<li><p><strong>chunksize</strong> – Portions of data to process at once.  Can be used
to keep memory consumption low.  Only useful together
with <cite>mmap</cite>.</p></li>
<li><p><strong>progress</strong> – Wether to show a progress bar.</p></li>
<li><p><strong>**kwargs</strong> – Pass on to whatever is used as <cite>method</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If <cite>method</cite> not known.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.CNN.calc_neighbours_from_cKDTree">
<code class="sig-name descname">calc_neighbours_from_cKDTree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">other</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Type<span class="p">[</span>CNN<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">format</span><span class="o">=</span><span class="default_value">'array_arrays'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.CNN.calc_neighbours_from_cKDTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate neighbourhoods from tree structure</p>
<p>Requires <code class="xref py py-attr docutils literal notranslate"><span class="pre">Data.points.tree</span></code>, computes neighbourhoods
using <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.cKDTree.query_ball_tree.html">scipy.spatial.cKDTree.query_ball_tree</a> and sets
<a class="reference internal" href="#cnnclustering.cnn.Data.neighbourhoods" title="cnnclustering.cnn.Data.neighbourhoods"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Data.neighbourhoods</span></code></a>.  See also <a class="reference internal" href="#cnnclustering.cnn.Points.cKDTree" title="cnnclustering.cnn.Points.cKDTree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Points.cKDTree()</span></code></a>
to build a suitable tree structure from data points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> – Search query radius.</p></li>
<li><p><strong>other</strong> – If not <cite>None</cite>, another <a class="reference internal" href="#cnnclustering.cnn.CNN" title="cnnclustering.cnn.CNN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CNN</span></code></a> instance whose data
points should be used for a relative neighbour search.
Also requires  <code class="xref py py-attr docutils literal notranslate"><span class="pre">other.data.points.tree</span></code>.</p></li>
<li><p><strong>format</strong> – <p>Output format for the created
neighbourhoods:</p>
<blockquote>
<div><ul>
<li><p>”list_sets”: List of sets of integer point indices
(<a class="reference internal" href="#cnnclustering.cnn.NeighbourhoodsList" title="cnnclustering.cnn.NeighbourhoodsList"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NeighbourhoodsList</span></code></a>).</p></li>
<li><p>”array_arrays”: 1D NumPy array of 1D NumPy arrays
of integer point indices
(<a class="reference internal" href="#cnnclustering.cnn.NeighbourhoodsArray" title="cnnclustering.cnn.NeighbourhoodsArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NeighbourhoodsArray</span></code></a>).</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>**kwargs</strong> – Keyword args passed on to
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.cKDTree.query_ball_tree.html">scipy.spatial.cKDTree.query_ball_tree</a></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.CNN.calc_neighbours_from_dist">
<code class="sig-name descname">calc_neighbours_from_dist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">format</span><span class="o">=</span><span class="default_value">'array_arrays'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.CNN.calc_neighbours_from_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate neighbourhoods from distances</p>
<p>Requires <a class="reference internal" href="#cnnclustering.cnn.Data.distances" title="cnnclustering.cnn.Data.distances"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Data.distances</span></code></a>, computes neighbourhoods
and sets <a class="reference internal" href="#cnnclustering.cnn.Data.neighbourhoods" title="cnnclustering.cnn.Data.neighbourhoods"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Data.neighbourhoods</span></code></a>.</p>
<dl class="simple">
<dt>Note: Currently only working for distance objects of</dt><dd><p>type <a class="reference internal" href="#cnnclustering.cnn.Distances" title="cnnclustering.cnn.Distances"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distances</span></code></a>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> – Search query radius.</p></li>
<li><p><strong>format</strong> – <p>Output format for the created
neighbourhoods:</p>
<blockquote>
<div><ul>
<li><p>”list_sets”: List of sets of integer point indices
(<a class="reference internal" href="#cnnclustering.cnn.NeighbourhoodsList" title="cnnclustering.cnn.NeighbourhoodsList"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NeighbourhoodsList</span></code></a>).</p></li>
<li><p>”array_arrays”: 1D NumPy array of 1D NumPy arrays
of integer point indices
(<a class="reference internal" href="#cnnclustering.cnn.NeighbourhoodsArray" title="cnnclustering.cnn.NeighbourhoodsArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NeighbourhoodsArray</span></code></a>).</p></li>
</ul>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.CNN.check">
<code class="sig-name descname">check</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.CNN.check" title="Permalink to this definition">¶</a></dt>
<dd><p>Check current data state</p>
<p>Check if data points, distances, neighbourhoods or a density
graph are present.
Check depends on length of the stored objects.  An empty
data structure (length = 0) represents no data.
Sets <a class="reference internal" href="#cnnclustering.cnn.CNN.status" title="cnnclustering.cnn.CNN.status"><code class="xref py py-attr docutils literal notranslate"><span class="pre">status</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.CNN.cut">
<code class="sig-name descname">cut</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">part</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">points</span><span class="p">:</span> <span class="n">Tuple[Optional[int], …]</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dimensions</span><span class="p">:</span> <span class="n">Tuple[Optional[int], …]</span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.CNN.cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new <a class="reference internal" href="#cnnclustering.cnn.CNN" title="cnnclustering.cnn.CNN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CNN</span></code></a> instance from a data subset</p>
<p>Convenience function to create a reduced cluster object.
Supported are continuous slices from the original data that
allow making a view instead of a copy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>part</strong> – Cut out the points for exactly one part
(zero based index).</p></li>
<li><p><strong>points</strong> – Slice points by using (start:stop:step)</p></li>
<li><p><strong>dimensions</strong> – Slice dimensions by using (start:stop:step)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="#cnnclustering.cnn.CNN" title="cnnclustering.cnn.CNN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CNN</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.CNN.dist_hist">
<code class="sig-name descname">dist_hist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ax</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Type<span class="p">[</span>matplotlib.axes._subplots.SubplotBase<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">maxima</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">maxima_props</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">hist_props</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ax_props</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inter_props</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.CNN.dist_hist" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a histogram of distances in the data set</p>
<p>Requires <code class="xref py py-attr docutils literal notranslate"><span class="pre">data.distances</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ax</strong> – Matplotlib Axes to plot on. If <cite>None</cite>, Figure and Axes
are created.</p></li>
<li><p><strong>maxima</strong> – Whether to mark the maxima of the
distribution. Uses <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.argrelextrema.html">scipy.signal.argrelextrema</a>.</p></li>
<li><p><strong>maxima_props</strong> – Keyword arguments passed to
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.argrelextrema.html">scipy.signal.argrelextrema</a> if <cite>maxima</cite> is set
to True.</p></li>
<li><p><strong>hist_props</strong> – Keyword arguments passed to
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.histogram.html">numpy.histogram</a> to compute the histogram.</p></li>
<li><p><strong>ax_props</strong> – Keyword arguments for Matplotlib Axes styling.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.CNN.evaluate">
<code class="sig-name descname">evaluate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ax</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Type<span class="p">[</span>matplotlib.axes._subplots.SubplotBase<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">clusters</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Collection<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">original</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">plot</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'dots'</span></em>, <em class="sig-param"><span class="n">points</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Tuple<span class="p">[</span>Optional<span class="p">[</span>int<span class="p">]</span><span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dim</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Tuple<span class="p">[</span>int<span class="p">, </span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ax_props</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">annotate</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">annotate_pos</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'mean'</span></em>, <em class="sig-param"><span class="n">annotate_props</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">plot_props</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">plot_noise_props</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">hist_props</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">free_energy</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.CNN.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a 2D plot of an original data set or a cluster result</p>
<dl>
<dt>Args: ax: The <cite>Axes</cite> instance to which to add the plot.  If</dt><dd><p><cite>None</cite>, a new <cite>Figure</cite> with <cite>Axes</cite> will be created.</p>
<dl>
<dt>clusters:</dt><dd><p>Cluster numbers to include in the plot.  If <cite>None</cite>,
consider all.</p>
</dd>
<dt>original:</dt><dd><p>Allows to plot the original data instead of a cluster
result.  Overrides <cite>clusters</cite>.  Will be considered
<cite>True</cite>, if no cluster result is present.</p>
</dd>
<dt>plot:</dt><dd><p>The kind of plotting method to use.</p>
<blockquote>
<div><ul class="simple">
<li><p>“dots”, <code class="xref py py-func docutils literal notranslate"><span class="pre">ax.plot()</span></code></p></li>
<li><p>“scatter”, <code class="xref py py-func docutils literal notranslate"><span class="pre">ax.scatter()</span></code></p></li>
<li><p>“contour”, <code class="xref py py-func docutils literal notranslate"><span class="pre">ax.contour()</span></code></p></li>
<li><p>“contourf”, <code class="xref py py-func docutils literal notranslate"><span class="pre">ax.contourf()</span></code></p></li>
</ul>
</div></blockquote>
</dd>
<dt>parts:</dt><dd><p>Use a slice (start, stop, stride) on the data parts
before plotting.</p>
</dd>
<dt>points:</dt><dd><p>Use a slice (start, stop, stride) on the data points
before plotting.</p>
</dd>
<dt>dim:</dt><dd><p>Use these two dimensions for plotting.  If <cite>None</cite>, uses
(0, 1).</p>
</dd>
<dt>annotate:</dt><dd><p>If there is a cluster result, plot the cluster numbers.
Uses <cite>annotate_pos</cite> to determinte the position of the
annotations.</p>
</dd>
<dt>annotate_pos:</dt><dd><p>Where to put the cluster number annotation.
Can be one of:</p>
<blockquote>
<div><ul class="simple">
<li><p>“mean”, Use the cluster mean</p></li>
<li><p>“random”, Use a random point of the cluster</p></li>
</ul>
</div></blockquote>
<p>Alternatively a list of x, y positions can be passed to
set a specific point for each cluster
(<em>Not yet implemented</em>)</p>
</dd>
<dt>annotate_props:</dt><dd><p>Dictionary of keyword arguments passed to
<code class="xref py py-func docutils literal notranslate"><span class="pre">ax.annotate()</span></code>.</p>
</dd>
<dt>ax_props:</dt><dd><p>Dictionary of <cite>ax</cite> properties to apply after
plotting via <code class="xref py py-func docutils literal notranslate"><span class="pre">ax.set(**ax_props)()</span></code>.  If <cite>None</cite>,
uses defaults that can be also defined in
the configuration file (<em>Note yet implemented</em>).</p>
</dd>
<dt>plot_props:</dt><dd><p>Dictionary of keyword arguments passed to various
functions (<code class="xref py py-func docutils literal notranslate"><span class="pre">_plots.plot_dots()</span></code> etc.) with different
meaning to format cluster plotting.  If <cite>None</cite>, uses
defaults that can be also defined in
the configuration file (<em>Note yet implemented</em>).</p>
</dd>
<dt>plot_noise_props:</dt><dd><p>Like <cite>plot_props</cite> but for formatting noise point
plotting.</p>
</dd>
<dt>hist_props:</dt><dd><p>Dictionary of keyword arguments passed to functions that
involve the computing of a histogram via
<cite>numpy.histogram2d</cite>.</p>
</dd>
<dt>free_energy:</dt><dd><p>If <cite>True</cite>, converts computed histograms to pseudo free
energy surfaces.</p>
</dd>
<dt>mask:</dt><dd><p>Sequence of boolean or integer values used for optional
fancy indexing on the point data array.  Note, that this
is applied after regular slicing (e.g. via <cite>points</cite>) and
requires a copy of the indexed data (may be slow and
memory intensive for big data sets).</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Figure, Axes and a list of plotted elements</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.CNN.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span> &#x2192; Optional<span class="p">[</span>Tuple<span class="p">[</span><a class="reference internal" href="#cnnclustering.cnn.CNNRecord" title="cnnclustering.cnn.CNNRecord">cnnclustering.cnn.CNNRecord</a><span class="p">, </span>bool<span class="p">]</span><span class="p">]</span><a class="headerlink" href="#cnnclustering.cnn.CNN.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps CNN clustering execution</p>
<p>Requires one of <a class="reference internal" href="#cnnclustering.cnn.Data.graph" title="cnnclustering.cnn.Data.graph"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Data.graph</span></code></a>, <a class="reference internal" href="#cnnclustering.cnn.Data.neighbourhoods" title="cnnclustering.cnn.Data.neighbourhoods"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Data.neighbourhoods</span></code></a>,
<a class="reference internal" href="#cnnclustering.cnn.Data.distances" title="cnnclustering.cnn.Data.distances"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Data.distances</span></code></a>, or <a class="reference internal" href="#cnnclustering.cnn.Data.points" title="cnnclustering.cnn.Data.points"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Data.points</span></code></a> and sets
<a class="reference internal" href="#cnnclustering.cnn.CNN.labels" title="cnnclustering.cnn.CNN.labels"><code class="xref py py-attr docutils literal notranslate"><span class="pre">labels</span></code></a>.</p>
<p>This function prepares the clustering and calls an appropriate
worker function to do the actual clustering.  How the clustering
is done, depends on the current data situation and the selected
<cite>policy</cite>. The clustering can be done with different inputs:</p>
<blockquote>
<div><ul class="simple">
<li><p>data points (<a class="reference internal" href="#cnnclustering.cnn.Points" title="cnnclustering.cnn.Points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Points</span></code></a>)</p></li>
<li><p>pre-computed pairwise point distances (<a class="reference internal" href="#cnnclustering.cnn.Distances" title="cnnclustering.cnn.Distances"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distances</span></code></a>)</p></li>
<li><dl class="simple">
<dt>pre-computed neighbourhoods</dt><dd><p>(<a class="reference internal" href="#cnnclustering.cnn.NeighbourhoodsArray" title="cnnclustering.cnn.NeighbourhoodsArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NeighbourhoodsArray</span></code></a>, <a class="reference internal" href="#cnnclustering.cnn.NeighbourhoodsList" title="cnnclustering.cnn.NeighbourhoodsList"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NeighbourhoodsList</span></code></a>)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>pre-computed density graph</dt><dd><p>(<code class="xref py py-obj docutils literal notranslate"><span class="pre">DensitySparsegraphArray</span></code>)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>The differing input structures have varying memory demands.  In
particular storage of distances can be costly memory-wise
(memory complexity <span class="math notranslate nohighlight">\(\mathcal{O}(n^2)\)</span>).
Ultimately, the clustering depends on neighbourhood or density
graph information. The clustering is fast if neighbourhoods or
a density graph are
pre-computed but this has to be re-done for each <cite>radius_cutoff</cite>
and/or <cite>cnn_cutoff</cite> separately. Neighbourhoods
can be calculated either from data
points (e.g. <a class="reference internal" href="#cnnclustering.cnn.CNN.calc_neighbours_from_cKDTree" title="cnnclustering.cnn.CNN.calc_neighbours_from_cKDTree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calc_neighbours_from_cKDTree()</span></code></a>),
or pre-computed pairwaise distances
(e.g. <a class="reference internal" href="#cnnclustering.cnn.CNN.calc_neighbours_from_dist" title="cnnclustering.cnn.CNN.calc_neighbours_from_dist"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calc_neighbours_from_dist()</span></code></a>).  The user
is encouraged to apply any external method of choice to provide
neighbourhoods in a format that can be clustered.
If a primary input structure (points or
distances) is given, neighbourhoods will be computed.
If the user chooses
<cite>policy = “progressive”</cite>, neighbourhoods will be computed from
either distances (if present) or points before the clustering
automatically.
If the user chooses <cite>policy = “conservative”</cite>, neighbourhoods
will be computed on-the-fly (online) from either distances (if
present) or points during the clustering.  This can save memory
but can be computational more expensive.  Caching can be used to
achieve the right balance between memory usage and computing
effort for your situation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>radius_cutoff</strong> – Radius cutoff cluster parameter.</p></li>
<li><p><strong>cnn_cutoff</strong> – CNN cutoff cluster parameter
(similarity criterion).</p></li>
<li><p><strong>member_cutoff</strong> – Valid clusters need to have at least this
many members.  Passed to <a class="reference internal" href="#cnnclustering.cnn.Labels.sort_by_size" title="cnnclustering.cnn.Labels.sort_by_size"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Labels.sort_by_size()</span></code></a>
if <cite>sort_by_size</cite> is <cite>True</cite>.  Has no effect otherwise
and valid clusters have at least two members.</p></li>
<li><p><strong>max_clusters</strong> – Keep only the largest <cite>max_clusters</cite> clusters.
Passed to <a class="reference internal" href="#cnnclustering.cnn.Labels.sort_by_size" title="cnnclustering.cnn.Labels.sort_by_size"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Labels.sort_by_size()</span></code></a>
if <cite>sort_by_size</cite> is <cite>True</cite>.  Has no effect otherwise.</p></li>
<li><p><strong>cnn_offset</strong> – Exists for compatibility reasons and is
substracted from <cite>cnn_cutoff</cite>.  If <cite>cnn_offset = 0</cite>, two
points need to share at least <cite>cnn_cutoff</cite> neighbours
to be part of the same cluster without counting any of
the two points.  In former versions of the clustering,
self-counting was included and <cite>cnn_cutoff = 2</cite> was
equivalent to <cite>cnn_cutoff = 0</cite> in this version.</p></li>
<li><p><strong>info</strong> – Weather to attach <a class="reference internal" href="#cnnclustering.cnn.LabelInfo" title="cnnclustering.cnn.LabelInfo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LabelInfo</span></code></a> to created
<a class="reference internal" href="#cnnclustering.cnn.Labels" title="cnnclustering.cnn.Labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Labels</span></code></a> instance.</p></li>
<li><p><strong>sort_by_size</strong> – Weather to sort (and trim) the created
<a class="reference internal" href="#cnnclustering.cnn.Labels" title="cnnclustering.cnn.Labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Labels</span></code></a> instance.  See also
<a class="reference internal" href="#cnnclustering.cnn.Labels.sort_by_size" title="cnnclustering.cnn.Labels.sort_by_size"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Labels.sort_by_size()</span></code></a>.</p></li>
<li><p><strong>rec</strong> – Weather to create and return a <a class="reference internal" href="#cnnclustering.cnn.CNNRecord" title="cnnclustering.cnn.CNNRecord"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CNNRecord</span></code></a>
instance in the end.</p></li>
<li><p><strong>v</strong> – Be chatty.</p></li>
<li><p><strong>policy</strong> – <p>Determines the computation behaviour depending on
the given data situation:</p>
<blockquote>
<div><ul>
<li><dl class="simple">
<dt>”progressive”: Bulk-compute neighbourhoods</dt><dd><p>if needed.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>”conservative”: Compute neighbourhoods on-the-fly</dt><dd><p>if needed.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Tuple(<a class="reference internal" href="#cnnclustering.cnn.CNNRecord" title="cnnclustering.cnn.CNNRecord"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CNNRecord</span></code></a>, <cite>v</cite>) if <cite>rec</cite> is <cite>True</cite>,
<cite>None</cite> otherwise</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>AssertionError</strong> – If <cite>policy</cite> is not in
    [“progressive”, “conservative”]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.CNN.get_dtraj">
<code class="sig-name descname">get_dtraj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.CNN.get_dtraj" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform cluster labels to discrete trajectories</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>[description]</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[type]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.CNN.get_samples">
<code class="sig-name descname">get_samples</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">kind</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'mean'</span></em>, <em class="sig-param"><span class="n">clusters</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>List<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">n_samples</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">1</span></em>, <em class="sig-param"><span class="n">by_parts</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">skip</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">0</span></em>, <em class="sig-param"><span class="n">stride</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">1</span></em><span class="sig-paren">)</span> &#x2192; Dict<span class="p">[</span>int<span class="p">, </span>List<span class="p">[</span>int<span class="p">]</span><span class="p">]</span><a class="headerlink" href="#cnnclustering.cnn.CNN.get_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Select sample points from clusters</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kind</strong> – <p>How to choose the
samples:</p>
<blockquote>
<div><ul>
<li><p>”mean”:</p></li>
<li><p>”random”:</p></li>
<li><p>”all”:</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>clusters</strong> – List of cluster numbers to consider</p></li>
<li><p><strong>n_samples</strong> – How many samples to return</p></li>
<li><p><strong>byparts</strong> – Return point indices as list of lists by parts</p></li>
<li><p><strong>skip</strong> – Skip the first <em>n</em> frames</p></li>
<li><p><strong>stride</strong> – Take only every <em>n</em> th frame</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Dictionary of sample point indices as list for
each cluster</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.CNN.isolate">
<code class="sig-name descname">isolate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">purge</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#cnnclustering.cnn.CNN.isolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Isolates points per clusters based on a cluster result</p>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.CNN.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#cnnclustering.cnn.CNN.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps CNN cluster prediction execution</p>
<p>Predict labels for points in a data set (<cite>other</cite>) on the basis
of assigned labels to a “train” set (<cite>self</cite>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> – <a class="reference internal" href="#cnnclustering.cnn.CNN" title="cnnclustering.cnn.CNN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CNN</span></code></a> cluster object for whose points cluster
labels should be predicted.</p></li>
<li><p><strong>radius_cutoff</strong> – Find nearest neighbours within
distance <em>r</em>.</p></li>
<li><p><strong>cnn_cutoff</strong> – Points of the same cluster must have
at least <em>c</em> common nearest neighbours
(similarity criterion).</p></li>
<li><p><strong>include_all</strong> – If <cite>False</cite>, keep cluster assignment for points in the
test set that have a maximum distance of <cite>same_tol</cite>
to a point in the train set, i.e. they are essentially
the same point (currently not implemented).</p></li>
<li><p><strong>same_tol</strong> – Distance cutoff to treat points as the same, if
<cite>include_all</cite> is <cite>False</cite>.</p></li>
<li><p><strong>clusters</strong> – Predict assignment of points only with respect to
this list of clusters.</p></li>
<li><p><strong>purge</strong> – If <cite>True</cite>, reinitalise predicted labels.
Override assignment memory.</p></li>
<li><p><strong>cnn_offset</strong> – Mainly for backwards compatibility.
Modifies the the <cite>cnn_cutoff</cite>.</p></li>
<li><p><strong>policy</strong> – <p>Determines the computation behaviour depending on
the given data situation:</p>
<blockquote>
<div><ul>
<li><dl class="simple">
<dt>”progressive”: Bulk-compute neighbourhoods</dt><dd><p>if needed.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>”conservative”: Compute neighbourhoods on-the-fly</dt><dd><p>if needed.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>Returns</strong> – None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.CNN.reel">
<code class="sig-name descname">reel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">deep</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">1</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#cnnclustering.cnn.CNN.reel" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap up assigments of lower hierarchy levels</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>deep</strong> – How many lower levels to consider.  If <cite>None</cite>,
consider all.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cnnclustering.cnn.CNNChild">
<em class="property">class </em><code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">CNNChild</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parent</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">alias</span><span class="o">=</span><span class="default_value">'child'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.CNNChild" title="Permalink to this definition">¶</a></dt>
<dd><p>CNN cluster object subclass.</p>
<p>Increments the hierarchy level of
the parent object when instanciated.</p>
<dl class="py attribute">
<dt id="cnnclustering.cnn.CNNChild.parent">
<code class="sig-name descname">parent</code><a class="headerlink" href="#cnnclustering.cnn.CNNChild.parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Reference to parent</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cnnclustering.cnn.CNNRecord">
<em class="property">class </em><code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">CNNRecord</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">c</span></em>, <em class="sig-param"><span class="n">min</span></em>, <em class="sig-param"><span class="n">max</span></em>, <em class="sig-param"><span class="n">clusters</span></em>, <em class="sig-param"><span class="n">largest</span></em>, <em class="sig-param"><span class="n">noise</span></em>, <em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.CNNRecord" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py attribute">
<dt id="cnnclustering.cnn.CNNRecord.c">
<code class="sig-name descname">c</code><a class="headerlink" href="#cnnclustering.cnn.CNNRecord.c" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.CNNRecord.clusters">
<code class="sig-name descname">clusters</code><a class="headerlink" href="#cnnclustering.cnn.CNNRecord.clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 5</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.CNNRecord.largest">
<code class="sig-name descname">largest</code><a class="headerlink" href="#cnnclustering.cnn.CNNRecord.largest" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 6</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.CNNRecord.max">
<code class="sig-name descname">max</code><a class="headerlink" href="#cnnclustering.cnn.CNNRecord.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 4</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.CNNRecord.min">
<code class="sig-name descname">min</code><a class="headerlink" href="#cnnclustering.cnn.CNNRecord.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 3</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.CNNRecord.noise">
<code class="sig-name descname">noise</code><a class="headerlink" href="#cnnclustering.cnn.CNNRecord.noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 7</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.CNNRecord.points">
<code class="sig-name descname">points</code><a class="headerlink" href="#cnnclustering.cnn.CNNRecord.points" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.CNNRecord.r">
<code class="sig-name descname">r</code><a class="headerlink" href="#cnnclustering.cnn.CNNRecord.r" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.CNNRecord.time">
<code class="sig-name descname">time</code><a class="headerlink" href="#cnnclustering.cnn.CNNRecord.time" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 8</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cnnclustering.cnn.Data">
<em class="property">class </em><code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">Data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">distances</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">neighbourhoods</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">graph</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.Data" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstraction class for handling input data</p>
<p>A data object bundles points, distances, neighbourhoods and
density graphs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> – Used to set <a class="reference internal" href="#cnnclustering.cnn.Data.points" title="cnnclustering.cnn.Data.points"><code class="xref py py-attr docutils literal notranslate"><span class="pre">points</span></code></a>.  If <cite>None</cite>, creates an
empty instance of <a class="reference internal" href="#cnnclustering.cnn.Points" title="cnnclustering.cnn.Points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Points</span></code></a>.  If an instance of
<a class="reference internal" href="#cnnclustering.cnn.Points" title="cnnclustering.cnn.Points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Points</span></code></a> is passed, uses this instance.  If anything
else is passed, tries to create an instance of
<a class="reference internal" href="#cnnclustering.cnn.Points" title="cnnclustering.cnn.Points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Points</span></code></a> using <a class="reference internal" href="#cnnclustering.cnn.Points.from_parts" title="cnnclustering.cnn.Points.from_parts"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Points.from_parts()</span></code></a>.</p></li>
<li><p><strong>distances</strong> – Used to set <a class="reference internal" href="#cnnclustering.cnn.Data.distances" title="cnnclustering.cnn.Data.distances"><code class="xref py py-attr docutils literal notranslate"><span class="pre">distances</span></code></a>.  If <cite>None</cite>, creates
an empty instance of <a class="reference internal" href="#cnnclustering.cnn.Distances" title="cnnclustering.cnn.Distances"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distances</span></code></a>.  If an instance of
<a class="reference internal" href="#cnnclustering.cnn.Distances" title="cnnclustering.cnn.Distances"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distances</span></code></a> is passed, uses this instance.  If anything
else is passed, tries to create an instance of
<a class="reference internal" href="#cnnclustering.cnn.Distances" title="cnnclustering.cnn.Distances"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distances</span></code></a> using the default constructor.</p></li>
<li><p><strong>neighbourhoods</strong> – Used to set <a class="reference internal" href="#cnnclustering.cnn.Data.neighbourhoods" title="cnnclustering.cnn.Data.neighbourhoods"><code class="xref py py-attr docutils literal notranslate"><span class="pre">neighbourhoods</span></code></a>.
If <cite>None</cite>, creates
an empty instance of <a class="reference internal" href="#cnnclustering.cnn.NeighbourhoodsArray" title="cnnclustering.cnn.NeighbourhoodsArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NeighbourhoodsArray</span></code></a>.
If an instance of a class qualifying as neighbourhoods
object (see <a class="reference internal" href="#cnnclustering.cnn.NeighbourhoodsABC" title="cnnclustering.cnn.NeighbourhoodsABC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NeighbourhoodsABC</span></code></a>) is passed, uses this
instance.  If anything
else is passed, tries to create an instance of
<a class="reference internal" href="#cnnclustering.cnn.NeighbourhoodsArray" title="cnnclustering.cnn.NeighbourhoodsArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NeighbourhoodsArray</span></code></a> using the default constructor.</p></li>
<li><p><strong>graph</strong> – Used to set <code class="xref py py-attr docutils literal notranslate"><span class="pre">graph.</span>
<span class="pre">If</span> <span class="pre">`None</span></code>, creates
an empty instance of <code class="xref py py-obj docutils literal notranslate"><span class="pre">DensitySparsegraphArray</span></code>.
If an instance of a class qualifying as density graph object
(see <a class="reference internal" href="#cnnclustering.cnn.DensitygraphABC" title="cnnclustering.cnn.DensitygraphABC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DensitygraphABC</span></code></a>) is passed, uses this
instance.  If anything
else is passed, tries to create an instance of
<code class="xref py py-obj docutils literal notranslate"><span class="pre">DensitySparsegraphArray</span></code> using the
default constructor.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="cnnclustering.cnn.Data.shape">
<code class="sig-name descname">shape</code><a class="headerlink" href="#cnnclustering.cnn.Data.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary summarising size of data structures.</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.Data.points">
<code class="sig-name descname">points</code><a class="headerlink" href="#cnnclustering.cnn.Data.points" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance of <a class="reference internal" href="#cnnclustering.cnn.Points" title="cnnclustering.cnn.Points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Points</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.Data.distances">
<code class="sig-name descname">distances</code><a class="headerlink" href="#cnnclustering.cnn.Data.distances" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance of <a class="reference internal" href="#cnnclustering.cnn.Distances" title="cnnclustering.cnn.Distances"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distances</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.Data.neighbourhoods">
<code class="sig-name descname">neighbourhoods</code><a class="headerlink" href="#cnnclustering.cnn.Data.neighbourhoods" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance of subclass of
<a class="reference internal" href="#cnnclustering.cnn.NeighbourhoodsABC" title="cnnclustering.cnn.NeighbourhoodsABC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NeighbourhoodsABC</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.Data.graph">
<code class="sig-name descname">graph</code><a class="headerlink" href="#cnnclustering.cnn.Data.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance of subclass of
<a class="reference internal" href="#cnnclustering.cnn.DensitygraphABC" title="cnnclustering.cnn.DensitygraphABC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DensitygraphABC</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cnnclustering.cnn.Densitygraph">
<em class="property">class </em><code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">Densitygraph</code><a class="headerlink" href="#cnnclustering.cnn.Densitygraph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="cnnclustering.cnn.DensitygraphABC">
<em class="property">class </em><code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">DensitygraphABC</code><a class="headerlink" href="#cnnclustering.cnn.DensitygraphABC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="cnnclustering.cnn.Distances">
<em class="property">class </em><code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">Distances</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>numpy.ndarray<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reference</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.Distances" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstraction class for data point distances</p>
</dd></dl>

<dl class="py class">
<dt id="cnnclustering.cnn.LabelInfo">
<em class="property">class </em><code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">LabelInfo</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">origin</span></em>, <em class="sig-param"><span class="n">reference</span></em>, <em class="sig-param"><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.LabelInfo" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py attribute">
<dt id="cnnclustering.cnn.LabelInfo.origin">
<code class="sig-name descname">origin</code><a class="headerlink" href="#cnnclustering.cnn.LabelInfo.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.LabelInfo.params">
<code class="sig-name descname">params</code><a class="headerlink" href="#cnnclustering.cnn.LabelInfo.params" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.LabelInfo.reference">
<code class="sig-name descname">reference</code><a class="headerlink" href="#cnnclustering.cnn.LabelInfo.reference" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cnnclustering.cnn.Labels">
<em class="property">class </em><code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">Labels</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sequence</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">info</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">consider</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.Labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Cluster label assignments</p>
<p>Inherits from <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sequence</strong> – Any 1D sequence that can be converted to a NumPy
array of integers representing cluster label assignments.
If <cite>None</cite>, will create an empty instance.</p></li>
<li><p><strong>info</strong> – Instance of <a class="reference internal" href="#cnnclustering.cnn.LabelInfo" title="cnnclustering.cnn.LabelInfo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LabelInfo</span></code></a> metadata.</p></li>
<li><p><strong>consider</strong> – Any 1D sequence matching the length of <cite>sequence</cite> of
0 and 1 used to set <a class="reference internal" href="#cnnclustering.cnn.Labels.consider" title="cnnclustering.cnn.Labels.consider"><code class="xref py py-attr docutils literal notranslate"><span class="pre">consider</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="cnnclustering.cnn.Labels.info">
<code class="sig-name descname">info</code><a class="headerlink" href="#cnnclustering.cnn.Labels.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance of <a class="reference internal" href="#cnnclustering.cnn.LabelInfo" title="cnnclustering.cnn.LabelInfo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LabelInfo</span></code></a> metadata.</p>
</dd></dl>

<dl class="py attribute">
<dt id="cnnclustering.cnn.Labels.consider">
<code class="sig-name descname">consider</code><a class="headerlink" href="#cnnclustering.cnn.Labels.consider" title="Permalink to this definition">¶</a></dt>
<dd><p>Array of 0 and 1 of same length as labels, indicating
which labels should be still considered (e.g. for
predictions).</p>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.Labels.dict2labels">
<em class="property">static </em><code class="sig-name descname">dict2labels</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dictionary</span><span class="p">:</span> <span class="n">Dict<span class="p">[</span>int<span class="p">, </span>Collection<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; Type<span class="p">[</span>numpy.ndarray<span class="p">]</span><a class="headerlink" href="#cnnclustering.cnn.Labels.dict2labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert cluster dictionary to labels</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dictionary</strong> – Dictionary of point indices per cluster label
to convert</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Sequenc of labels for each point as NumPy ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.Labels.fix_missing">
<code class="sig-name descname">fix_missing</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.Labels.fix_missing" title="Permalink to this definition">¶</a></dt>
<dd><p>Fix missing cluster labels and ensure continuous numbering</p>
<p>If you also want the labels to be sorted by clustersize use
<a class="reference internal" href="#cnnclustering.cnn.Labels.sort_by_size" title="cnnclustering.cnn.Labels.sort_by_size"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_by_size()</span></code></a> instead, which re-numbers clusters, too.</p>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.Labels.labels2dict">
<em class="property">static </em><code class="sig-name descname">labels2dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">labels</span><span class="p">:</span> <span class="n">Collection<span class="p">[</span>int<span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; Dict<span class="p">[</span>int<span class="p">, </span>Set<span class="p">[</span>int<span class="p">]</span><span class="p">]</span><a class="headerlink" href="#cnnclustering.cnn.Labels.labels2dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert labels to cluster dictionary</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>labels</strong> – Sequence of integer cluster labels to convert</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Dictionary of sets of point indices with cluster labels
as keys</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.Labels.merge">
<code class="sig-name descname">merge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">clusters</span><span class="p">:</span> <span class="n">List<span class="p">[</span>int<span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#cnnclustering.cnn.Labels.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge a list of clusters into one</p>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.Labels.sort_by_size">
<code class="sig-name descname">sort_by_size</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">member_cutoff</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_clusters</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.Labels.sort_by_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort labels by clustersize in-place</p>
<p>Re-assigns cluster numbers so that the biggest cluster (that is
not noise) is cluster 1.  Also filters clusters out, that have
not at least <cite>member_cutoff</cite> members.  Optionally, does only
keep the <cite>max_clusters</cite> largest clusters.  Returns the member
count in the largest cluster and the number of points declared
as noise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>member_cutoff</strong> – Valid clusters need to have at least this
many members.</p></li>
<li><p><strong>max_clusters</strong> – Only keep this many clusters.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(#member largest, #member noise)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.Labels.trash">
<code class="sig-name descname">trash</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">clusters</span><span class="p">:</span> <span class="n">List<span class="p">[</span>int<span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#cnnclustering.cnn.Labels.trash" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge a list of clusters into noise</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cnnclustering.cnn.MetaSettings">
<em class="property">class </em><code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">MetaSettings</code><a class="headerlink" href="#cnnclustering.cnn.MetaSettings" title="Permalink to this definition">¶</a></dt>
<dd><p>Metaclass to inherit class with class properties</p>
<p>Classes constructed with this metaclass have a <code class="xref py py-attr docutils literal notranslate"><span class="pre">__defaults</span></code>
class attribute that can be accessed as a property <code class="xref py py-attr docutils literal notranslate"><span class="pre">defaults</span></code>
from the class.</p>
</dd></dl>

<dl class="py class">
<dt id="cnnclustering.cnn.Neighbourhoods">
<em class="property">class </em><code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">Neighbourhoods</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">neighbourhoods</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">radius</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reference</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">self_counting</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.Neighbourhoods" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic realisation of neighbourhood abstraction</p>
<p>Inherits from <code class="xref py py-obj docutils literal notranslate"><span class="pre">NeighboursABC</span></code>.</p>
<p>Makes no assumptions on the nature of the stored neighbours and
provides default implementations for the required attributes by
<code class="xref py py-obj docutils literal notranslate"><span class="pre">NeighboursABC</span></code>.  Since working realisations of the
<a class="reference internal" href="#cnnclustering.cnn.Neighbourhoods" title="cnnclustering.cnn.Neighbourhoods"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Neighbourhoods</span></code></a> base class usually inherit with priority
from a collection type
whose <cite>__init__</cite> mechanism is probably used, the alternative method
<cite>init_finalise</cite> is offered to set the required attributes.</p>
<dl class="py method">
<dt id="cnnclustering.cnn.Neighbourhoods.n_neighbours">
<em class="property">property </em><code class="sig-name descname">n_neighbours</code><a class="headerlink" href="#cnnclustering.cnn.Neighbourhoods.n_neighbours" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of neighbours for each point</p>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.Neighbourhoods.radius">
<em class="property">property </em><code class="sig-name descname">radius</code><a class="headerlink" href="#cnnclustering.cnn.Neighbourhoods.radius" title="Permalink to this definition">¶</a></dt>
<dd><p>Return radius</p>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.Neighbourhoods.reference">
<em class="property">property </em><code class="sig-name descname">reference</code><a class="headerlink" href="#cnnclustering.cnn.Neighbourhoods.reference" title="Permalink to this definition">¶</a></dt>
<dd><p>Return reference CNN instance</p>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.Neighbourhoods.self_counting">
<em class="property">property </em><code class="sig-name descname">self_counting</code><a class="headerlink" href="#cnnclustering.cnn.Neighbourhoods.self_counting" title="Permalink to this definition">¶</a></dt>
<dd><p>Self-counting of points as their own neighbours?</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cnnclustering.cnn.NeighbourhoodsABC">
<em class="property">class </em><code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">NeighbourhoodsABC</code><a class="headerlink" href="#cnnclustering.cnn.NeighbourhoodsABC" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstraction class for neighbourhoods</p>
<p>Neighbourhoods (integer point indices) can be stored in different
data structures (non-exhaustive listing):</p>
<blockquote>
<div><p>Collection of collections:</p>
<blockquote>
<div><ul class="simple">
<li><p>list of sets (<a class="reference internal" href="#cnnclustering.cnn.NeighbourhoodsList" title="cnnclustering.cnn.NeighbourhoodsList"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NeighbourhoodsList</span></code></a>)</p></li>
<li><p>array of arrays (<a class="reference internal" href="#cnnclustering.cnn.NeighbourhoodsArray" title="cnnclustering.cnn.NeighbourhoodsArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NeighbourhoodsArray</span></code></a>)</p></li>
</ul>
</div></blockquote>
<p>Linear collection plus slice indicator:</p>
<blockquote>
<div><ul class="simple">
<li><p>array of neighbours plus array of starting indices
(<code class="xref py py-obj docutils literal notranslate"><span class="pre">NeighbourhoodsSparsegraphArray</span></code>)</p></li>
<li><p>array in which one element indicates the length and the
following elements are neighbours
(<a class="reference internal" href="#cnnclustering.cnn.NeighbourhoodsLinear" title="cnnclustering.cnn.NeighbourhoodsLinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NeighbourhoodsLinear</span></code></a>)</p></li>
</ul>
</div></blockquote>
</div></blockquote>
<p>To qualify as a neighbourhoods container, the following attributes
should be present in any case:</p>
<blockquote>
<div><dl class="simple">
<dt>radius: Points are neighbours of each other with respect to</dt><dd><p>this radius (any metric).</p>
</dd>
<dt>reference: A <a class="reference internal" href="#cnnclustering.cnn.CNN" title="cnnclustering.cnn.CNN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CNN</span></code></a> instance if neighbourhoods are valid for</dt><dd><p>points in different data sets.</p>
</dd>
<dt>n_neighbours: Return the neighbourcount for each point in</dt><dd><p>the container.</p>
</dd>
<dt>self_counting: Boolean indicator, True if neighbourhoods include</dt><dd><p>self-counting (point is its own neighbour).</p>
</dd>
<dt>__str__: A useful str-representation revealing the type and</dt><dd><p>the radius.</p>
</dd>
</dl>
</div></blockquote>
<dl class="py method">
<dt id="cnnclustering.cnn.NeighbourhoodsABC.n_neighbours">
<em class="property">abstract property </em><code class="sig-name descname">n_neighbours</code><a class="headerlink" href="#cnnclustering.cnn.NeighbourhoodsABC.n_neighbours" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of neighbours for each point</p>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.NeighbourhoodsABC.radius">
<em class="property">abstract property </em><code class="sig-name descname">radius</code><a class="headerlink" href="#cnnclustering.cnn.NeighbourhoodsABC.radius" title="Permalink to this definition">¶</a></dt>
<dd><p>Return radius</p>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.NeighbourhoodsABC.reference">
<em class="property">abstract property </em><code class="sig-name descname">reference</code><a class="headerlink" href="#cnnclustering.cnn.NeighbourhoodsABC.reference" title="Permalink to this definition">¶</a></dt>
<dd><p>Return reference CNN instance</p>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.NeighbourhoodsABC.self_counting">
<em class="property">abstract property </em><code class="sig-name descname">self_counting</code><a class="headerlink" href="#cnnclustering.cnn.NeighbourhoodsABC.self_counting" title="Permalink to this definition">¶</a></dt>
<dd><p>Self-counting of points as their own neighbours?</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cnnclustering.cnn.NeighbourhoodsArray">
<em class="property">class </em><code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">NeighbourhoodsArray</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sequence</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">radius</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reference</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">self_counting</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.NeighbourhoodsArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Array of array realisation of neighbourhood abstraction</p>
<p>Inherits from <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> and <a class="reference internal" href="#cnnclustering.cnn.Neighbourhoods" title="cnnclustering.cnn.Neighbourhoods"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Neighbourhoods</span></code></a>.</p>
<dl class="py method">
<dt id="cnnclustering.cnn.NeighbourhoodsArray.n_neighbours">
<em class="property">property </em><code class="sig-name descname">n_neighbours</code><a class="headerlink" href="#cnnclustering.cnn.NeighbourhoodsArray.n_neighbours" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of neighbours for each point</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cnnclustering.cnn.NeighbourhoodsLinear">
<em class="property">class </em><code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">NeighbourhoodsLinear</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sequence</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">radius</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reference</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.NeighbourhoodsLinear" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear representation of neighbourhoods</p>
<p>Inherits from <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> and <a class="reference internal" href="#cnnclustering.cnn.Neighbourhoods" title="cnnclustering.cnn.Neighbourhoods"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Neighbourhoods</span></code></a>.</p>
<p>Elements are neighbour counts of a specific point followed by
elements that are indices of neighbouring points.</p>
<dl class="py method">
<dt id="cnnclustering.cnn.NeighbourhoodsLinear.n_neighbours">
<em class="property">property </em><code class="sig-name descname">n_neighbours</code><a class="headerlink" href="#cnnclustering.cnn.NeighbourhoodsLinear.n_neighbours" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of neighbours for each point</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cnnclustering.cnn.NeighbourhoodsList">
<em class="property">class </em><code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">NeighbourhoodsList</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">neighbourhoods</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">radius</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reference</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.NeighbourhoodsList" title="Permalink to this definition">¶</a></dt>
<dd><p>List of sets realisation of neighbourhood abstraction</p>
<p>Inherits from <code class="xref py py-obj docutils literal notranslate"><span class="pre">collections.UserList</span></code> and <a class="reference internal" href="#cnnclustering.cnn.Neighbourhoods" title="cnnclustering.cnn.Neighbourhoods"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Neighbourhoods</span></code></a>.</p>
<dl class="py method">
<dt id="cnnclustering.cnn.NeighbourhoodsList.n_neighbours">
<em class="property">property </em><code class="sig-name descname">n_neighbours</code><a class="headerlink" href="#cnnclustering.cnn.NeighbourhoodsList.n_neighbours" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of neighbours for each point</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cnnclustering.cnn.Points">
<em class="property">class </em><code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">Points</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>numpy.ndarray<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">edges</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tree</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Any<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.Points" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstraction class for data points</p>
<dl class="py method">
<dt id="cnnclustering.cnn.Points.by_parts">
<code class="sig-name descname">by_parts</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Iterator<a class="headerlink" href="#cnnclustering.cnn.Points.by_parts" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield data by parts</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Generator of 2D <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> s (parts)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.Points.cKDTree">
<code class="sig-name descname">cKDTree</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.Points.cKDTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for <code class="xref py py-meth docutils literal notranslate"><span class="pre">scipy.spatial.cKDTree()</span></code></p>
<p>Sets <code class="xref py py-attr docutils literal notranslate"><span class="pre">Points.tree</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> – Passed to <code class="xref py py-meth docutils literal notranslate"><span class="pre">scipy.spatial.cKDTree()</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.Points.from_file">
<em class="property">classmethod </em><code class="sig-name descname">from_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>str<span class="p">, </span>pathlib.Path<span class="p">]</span></span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">from_parts</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.Points.from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Alternative constructor</p>
<dl>
<dt>Use if data is passed as collection of parts, as</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">Points</span><span class="o">.</span><span class="n">from_parts</span><span class="p">([[[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]]])</span>
</pre></div>
</div>
</dd>
<dt>Recognised input formats are:</dt><dd><ul class="simple">
<li><p>Sequence</p></li>
<li><p>2D Sequence (sequence of sequences all of same length)</p></li>
<li><p>Sequence of 2D sequences all of same second dimension</p></li>
</ul>
</dd>
</dl>
<p>In this way, part edges are taken from the input shape and do
not have to be specified explicitly. Calls <a class="reference internal" href="#cnnclustering.cnn.Points.get_shape" title="cnnclustering.cnn.Points.get_shape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_shape()</span></code></a>
and <a class="reference internal" href="#cnnclustering.cnn.Points.load" title="cnnclustering.cnn.Points.load"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>f</strong> – File name as string or <code class="xref py py-obj docutils literal notranslate"><span class="pre">pathlib.Path</span></code> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Instance of <a class="reference internal" href="#cnnclustering.cnn.Points" title="cnnclustering.cnn.Points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Points</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.Points.from_parts">
<em class="property">classmethod </em><code class="sig-name descname">from_parts</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.Points.from_parts" title="Permalink to this definition">¶</a></dt>
<dd><p>Alternative constructor</p>
<dl>
<dt>Use if data is passed as collection of parts, as</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">Points</span><span class="o">.</span><span class="n">from_parts</span><span class="p">([[[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]]])</span>
</pre></div>
</div>
</dd>
<dt>Recognised input formats are:</dt><dd><ul class="simple">
<li><p>Sequence</p></li>
<li><p>2D Sequence (sequence of sequences all of same length)</p></li>
<li><p>Sequence of 2D sequences all of same second dimension</p></li>
</ul>
</dd>
</dl>
<p>In this way, part edges are taken from the input shape and do
not have to be specified explicitly. Calls <a class="reference internal" href="#cnnclustering.cnn.Points.get_shape" title="cnnclustering.cnn.Points.get_shape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_shape()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>p</strong> – File name as string or <code class="xref py py-obj docutils literal notranslate"><span class="pre">pathlib.Path</span></code> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Instance of <a class="reference internal" href="#cnnclustering.cnn.Points" title="cnnclustering.cnn.Points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Points</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.Points.get_shape">
<em class="property">static </em><code class="sig-name descname">get_shape</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span><span class="p">:</span> <span class="n">Any</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.Points.get_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Maintain data in universal shape (2D NumPy array)</p>
<p>Analyses the format of given data and fits it into the standard
format (parts, points, dimensions).  Creates a
<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> vstacked along the parts componenent that
can be passed to the <cite>Points</cite> constructor alongside part edges.
This may not be able to deal with all possible kinds of input
structures correctly, so check the outcome carefully.</p>
<dl class="simple">
<dt>Recognised input formats are:</dt><dd><ul class="simple">
<li><p>Sequence</p></li>
<li><p>2D Sequence (sequence of sequences all of same length)</p></li>
<li><p>Sequence of 2D sequences all of same second dimension</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – <p>Either <cite>None</cite>
or:</p>
<ul class="simple">
<li><p>a 1D sequence of length <em>d</em>,
interpreted as 1 point in <em>d</em> dimension</p></li>
<li><p>a 2D sequence of length <em>n</em> (rows) and width
<em>d</em> (columns),
interpreted as <em>n</em> points in <em>d</em> dimensions</p></li>
<li><p>a list of 2D sequences,
interpreted as groups (parts) of points</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>Tuple of</p>
<blockquote>
<div><ul class="simple">
<li><p>NumPy array of shape (<span class="math notranslate nohighlight">\(\sum n, d\)</span>)</p></li>
<li><p>Part edges list, marking the end points of the
parts</p></li>
</ul>
</div></blockquote>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.Points.load">
<em class="property">static </em><code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>pathlib.Path<span class="p">, </span>str<span class="p">]</span></span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#cnnclustering.cnn.Points.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads file content</p>
<p>Depending on the filename extension, a suitable loader is
called:</p>
<blockquote>
<div><ul class="simple">
<li><p>.p: <code class="xref py py-func docutils literal notranslate"><span class="pre">pickle.load()</span></code></p></li>
<li><p>.npy: <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.load()</span></code></p></li>
<li><p>None: <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.loadtxt()</span></code></p></li>
<li><p>.xvg, .dat: <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.loadtxt()</span></code></p></li>
</ul>
</div></blockquote>
<p>Sets <code class="xref py py-attr docutils literal notranslate"><span class="pre">data</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> – File</p></li>
<li><p><strong>*args</strong> – Passed to loader</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>**kwargs</strong> – Passed to loader</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Return value of the loader</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cnnclustering.cnn.Settings">
<em class="property">class </em><code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">Settings</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.Settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to expose and handle configuration</p>
<p>Inherits from <a class="reference internal" href="#cnnclustering.cnn.MetaSettings" title="cnnclustering.cnn.MetaSettings"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaSettings</span></code></a> to allow access to the class
attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">__defaults</span></code> as a property <code class="xref py py-attr docutils literal notranslate"><span class="pre">defaults</span></code>.</p>
<p>Also derived from basic type <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>.</p>
<p>The user can sublclass this class <a class="reference internal" href="#cnnclustering.cnn.Settings" title="cnnclustering.cnn.Settings"><code class="xref py py-class docutils literal notranslate"><span class="pre">Settings</span></code></a> to provide e.g.
a different set of default values as <code class="xref py py-attr docutils literal notranslate"><span class="pre">__defaults</span></code>.</p>
<dl class="py method">
<dt id="cnnclustering.cnn.Settings.configure">
<code class="sig-name descname">configure</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Union<span class="p">[</span>pathlib.Path<span class="p">, </span>str<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reset</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.Settings.configure" title="Permalink to this definition">¶</a></dt>
<dd><p>Configuration file reading</p>
<p>Reads a yaml configuration file <code class="docutils literal notranslate"><span class="pre">.corerc</span></code> from a given path or
one of the standard locations in the following order of
priority:</p>
<blockquote>
<div><ul class="simple">
<li><p>current working directory</p></li>
<li><p>user home directory</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> – Path to a configuration file.</p></li>
<li><p><strong>reset</strong> – Reset to defaults. If True, <cite>path</cite> is ignored
and no configuration file is read.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.Settings.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">E</em>, <span class="optional">]</span><em class="sig-param">**F</em><span class="sig-paren">)</span> &#x2192; None.  Update D from dict/iterable E and F.<a class="headerlink" href="#cnnclustering.cnn.Settings.update" title="Permalink to this definition">¶</a></dt>
<dd><p>If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
In either case, this is followed by: for k in F:  D[k] = F[k]</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cnnclustering.cnn.SparsegraphArray">
<em class="property">class </em><code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">SparsegraphArray</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vertices</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">indices</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.SparsegraphArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse graph realisation of a graph using Numpy arrays</p>
<p>Can be used to represent neighbourhoods or a density connectivity
graph.</p>
</dd></dl>

<dl class="py class">
<dt id="cnnclustering.cnn.Summary">
<em class="property">class </em><code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">Summary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">iterable</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.Summary" title="Permalink to this definition">¶</a></dt>
<dd><p>List like container for cluster results</p>
<p>Stores instances of <a class="reference internal" href="#cnnclustering.cnn.CNNRecord" title="cnnclustering.cnn.CNNRecord"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CNNRecord</span></code></a>.</p>
<dl class="py method">
<dt id="cnnclustering.cnn.Summary.insert">
<code class="sig-name descname">insert</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">index</span></em>, <em class="sig-param"><span class="n">item</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.Summary.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>S.insert(index, value) – insert value before index</p>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.Summary.summarize">
<code class="sig-name descname">summarize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ax</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Type<span class="p">[</span>matplotlib.axes._subplots.SubplotBase<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">quant</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'time'</span></em>, <em class="sig-param"><span class="n">treat_nan</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Any<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ax_props</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">contour_props</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.Summary.summarize" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a 2D plot of record values</p>
<p>Record values (“time”, “clusters”, “largest”, “noise”) are
plotted against cluster parameters (radius cutoff <em>r</em>
and cnn cutoff <em>c</em>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ax</strong> – Matplotlib Axes to plot on.  If <cite>None</cite>, a new Figure
with Axes will be created.</p></li>
<li><p><strong>quant</strong> – <p>Record value to
visualise:</p>
<blockquote>
<div><ul>
<li><p>”time”</p></li>
<li><p>”clusters”</p></li>
<li><p>”largest”</p></li>
<li><p>”noise”</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>treat_nan</strong> – If not <cite>None</cite>, use this value to pad nan-values.</p></li>
<li><p><strong>ax_props</strong> – Used to style <cite>ax</cite>.</p></li>
<li><p><strong>contour_props</strong> – Passed on to contour.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cnnclustering.cnn.Summary.to_DataFrame">
<code class="sig-name descname">to_DataFrame</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.Summary.to_DataFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert list of records to (typed) pandas DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#cnnclustering.cnn.TypedDataFrame" title="cnnclustering.cnn.TypedDataFrame"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TypedDataFrame</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="cnnclustering.cnn.TypedDataFrame">
<code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">TypedDataFrame</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">columns</span></em>, <em class="sig-param"><span class="n">dtypes</span></em>, <em class="sig-param"><span class="n">content</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.TypedDataFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Optional constructor to convert CNNRecords to pandas.DataFrame</p>
</dd></dl>

<dl class="py function">
<dt id="cnnclustering.cnn.calc_dist">
<code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">calc_dist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span><span class="p">:</span> <span class="n">Any</span></em>, <em class="sig-param"><span class="n">other</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Any<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">v</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">method</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'cdist'</span></em>, <em class="sig-param"><span class="n">mmap</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">mmap_file</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Union<span class="p">[</span>pathlib.Path<span class="p">, </span>str<span class="p">, </span>IO<span class="p">[</span>bytes<span class="p">]</span><span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">chunksize</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">10000</span></em>, <em class="sig-param"><span class="n">progress</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span> &#x2192; Type<span class="p">[</span><a class="reference internal" href="#cnnclustering.cnn.Distances" title="cnnclustering.cnn.Distances">cnnclustering.cnn.Distances</a><span class="p">]</span><a class="headerlink" href="#cnnclustering.cnn.calc_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>High level wrapper function for <a class="reference internal" href="#cnnclustering.cnn.CNN.calc_dist" title="cnnclustering.cnn.CNN.calc_dist"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CNN.calc_dist()</span></code></a>.</p>
<p>A <a class="reference internal" href="#cnnclustering.cnn.CNN" title="cnnclustering.cnn.CNN"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNN</span></code></a> instance is created with the given data as data
points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – Data suitable to be interpreted as <a class="reference internal" href="#cnnclustering.cnn.Points" title="cnnclustering.cnn.Points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Points</span></code></a>.</p></li>
<li><p><strong>other</strong> – Second data suitable to be interpreted as <a class="reference internal" href="#cnnclustering.cnn.Points" title="cnnclustering.cnn.Points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Points</span></code></a>
used for relative distance computation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Distance matrix as instance of <a class="reference internal" href="#cnnclustering.cnn.Distances" title="cnnclustering.cnn.Distances"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distances</span></code></a> of shape
(<em>n</em>, <em>m</em>) with <em>n</em> points in <cite>data</cite> and <em>m</em> points in <cite>other</cite>.
If <cite>other</cite> is <cite>None</cite>, <em>m</em> = <em>n</em>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cnnclustering.cnn.fit">
<code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span><span class="p">:</span> <span class="n">Any</span></em>, <em class="sig-param"><span class="n">radius_cutoff</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>float<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cnn_cutoff</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">member_cutoff</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_clusters</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cnn_offset</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">info</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">sort_by_size</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">rec</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">v</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">policy</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>str<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; Type<span class="p">[</span><a class="reference internal" href="#cnnclustering.cnn.Labels" title="cnnclustering.cnn.Labels">cnnclustering.cnn.Labels</a><span class="p">]</span><a class="headerlink" href="#cnnclustering.cnn.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>High level wrapper function for <a class="reference internal" href="#cnnclustering.cnn.CNN.fit" title="cnnclustering.cnn.CNN.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CNN.fit()</span></code></a>.</p>
<p>A <a class="reference internal" href="#cnnclustering.cnn.CNN" title="cnnclustering.cnn.CNN"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNN</span></code></a> instance is created with the given data as data
points, distances, neighbourhoods or density graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – Data as instance of <a class="reference internal" href="#cnnclustering.cnn.Points" title="cnnclustering.cnn.Points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Points</span></code></a>, <a class="reference internal" href="#cnnclustering.cnn.Distances" title="cnnclustering.cnn.Distances"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distances</span></code></a>,
<a class="reference internal" href="#cnnclustering.cnn.Neighbourhoods" title="cnnclustering.cnn.Neighbourhoods"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Neighbourhoods</span></code></a>, <a class="reference internal" href="#cnnclustering.cnn.Densitygraph" title="cnnclustering.cnn.Densitygraph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Densitygraph</span></code></a> or any subclass.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Cluster label assignments as instance of <a class="reference internal" href="#cnnclustering.cnn.Labels" title="cnnclustering.cnn.Labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Labels</span></code></a>.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If data is not of suitable type.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cnnclustering.cnn.recorded">
<code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">recorded</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function_</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.recorded" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to format fit function feedback.</p>
<p>Used to decorate fit methods of <cite>CNN</cite> instances.  Feedback needs to
be sequence in record format, i.e. conforming to the <cite>CNNRecord</cite>
namedtuple.  If execution time was measured, the corresponding field
will be modified.</p>
</dd></dl>

<dl class="py data">
<dt id="cnnclustering.cnn.settings">
<code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">settings</code><em class="property"> = {'default_cnn_cutoff': '1', 'default_cnn_offset': '0', 'default_fit_policy': 'conservative', 'default_member_cutoff': '2', 'default_predict_policy': 'conservative', 'default_radius_cutoff': '1', 'float_precision': 'sp', 'int_precision': 'sp'}</em><a class="headerlink" href="#cnnclustering.cnn.settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Module level settings container</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#cnnclustering.cnn.Settings" title="cnnclustering.cnn.Settings"><code class="xref py py-class docutils literal notranslate"><span class="pre">Settings</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cnnclustering.cnn.timed">
<code class="sig-prename descclassname">cnnclustering.cnn.</code><code class="sig-name descname">timed</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function_</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cnnclustering.cnn.timed" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to measure execution time.</p>
<p>Forwards the output of the wrapped function and measured execution
time as a tuple.</p>
</dd></dl>

</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">cnnclustering</a></h1>



<p class="blurb">CNN clustering and csMSM estimation in Python</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=janjoswig&repo=CNN&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="api_reference.html">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">cnn - A Python module for common-nearest-neighbour (CNN) clustering</a></li>
<li class="toctree-l2"><a class="reference internal" href="api_cmsm.html">cmsm - A Python module for coreset Markov-state model estimation</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="api_reference.html">API Reference</a><ul>
      <li>Previous: <a href="api_reference.html" title="previous chapter">API Reference</a></li>
      <li>Next: <a href="api_cmsm.html" title="next chapter">cmsm - A Python module for coreset Markov-state model estimation</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Jan-Oliver Joswig.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.1.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/_source/api_cnn.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>